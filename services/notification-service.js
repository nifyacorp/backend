// Convert CommonJS imports to ES Modules
// import db from '../utils/db'; // Replaced by repository
import logger from '../utils/logger.js'; // Assuming ESM compatible
import metrics from '../utils/metrics.js'; // Assuming ESM compatible
// import { v4 as uuidv4 } from 'uuid'; // No longer needed if ID generated by DB
import eventEmitter from '../utils/event-emitter.js'; // Assuming ESM compatible
// import socketManager from '../utils/socket-manager.js'; // WebSocket functionality removed
import messageQueue from '../utils/message-queue.js'; // Assuming ESM compatible
import pubsubClient from '../utils/pubsub-client.js'; // Assuming ESM compatible
import { normalizeNotification, extractNotificationTitle } from '../utils/notification-helper.js'; // Assuming ESM compatible

// Import the new repository functions
import {
  createNotificationRecord,
  findUserNotifications,
  markNotificationRead,
  deleteNotificationById,
  deleteAllUserNotifications,
  countUnreadUserNotifications,
  findUserEmailPreferences
} from '../infrastructure/database/notification.repository.js';

// Import the new real-time service // WebSocket functionality removed
// import { deliverNotificationRealtime } from './realtime.service.js';

/**
 * Create a notification, persist it, and trigger delivery mechanisms.
 */
export async function createNotification({ userId, type, content, transactionId }) {
  logger.debug('Creating notification (service layer)', { userId, type, content, transactionId });

  try {
    const notificationData = {
      userId,
      type,
      content: JSON.stringify(content), // Ensure content is stringified before repo
      read: false,
      createdAt: new Date().toISOString()
    };

    // Store notification using the repository
    const notificationId = await createNotificationRecord(notificationData);
    logger.debug('Notification persisted via repository', { notificationId, correlationId: transactionId });

    // --- Event Publishing/Queuing (remains the same for now) ---
    // Decide if event publishing is still needed without real-time listeners
    if (process.env.USE_MESSAGE_QUEUE === 'true') {
      await messageQueue.publish('notifications', '', {
        type: 'NOTIFICATION_CREATED',
        payload: { notificationId, userId, type, content }, // Pass original content
        correlationId: transactionId
      });
      logger.debug('Notification published to queue', { notificationId, correlationId: transactionId });
    } else {
      // EventEmitter might be useful for in-process decoupling even without WebSockets
      eventEmitter.emit('NOTIFICATION_CREATED', {
        notificationId, userId, type, content, // Pass original content
        correlationId: transactionId
      });
      logger.debug('Notification event emitted directly', { notificationId, correlationId: transactionId });
    }

    // --- Real-time Delivery (WebSocket functionality removed) ---
    // No-op: The call to deliverNotificationRealtime is removed.
    logger.debug('Real-time delivery skipped (WebSocket functionality removed)', { notificationId, userId });

    // --- Email Notification Triggering ---
    try {
      // Fetch user preferences using the repository
      const userPrefs = await findUserEmailPreferences(userId);

      if (userPrefs && userPrefs.email_notifications) {
        const title = extractNotificationTitle(content, type, userId);
        const email = userPrefs.notification_email || userPrefs.email;

        if (email) {
          // Consider extracting this pub/sub logic later
          await publishToEmailNotificationTopic({
            notificationId,
            userId,
            email,
            notification: { // Construct payload for email topic
              id: notificationId,
              type,
              title,
              content, // Pass original content
              timestamp: notificationData.createdAt
            },
            transactionId
          });
          logger.debug('Email notification published', { notificationId, userId, email, correlationId: transactionId });
        }
      } else if (!userPrefs) {
           logger.warn('Could not trigger email notification because user preferences not found', { userId });
      }
    } catch (emailError) {
      logger.error('Error triggering email notification', { error: emailError.message, notificationId, userId, correlationId: transactionId });
      // Do not re-throw, allow main notification creation to succeed
    }

    metrics.increment('notification.created', { type, userId });

    return { // Return the logical notification object
      id: notificationId,
      userId,
      type,
      content, // Return original content object
      read: false
    };
  } catch (error) {
    logger.error('Error creating notification (service layer)', { error: error.message, stack: error.stack, userId, type, correlationId: transactionId });
    metrics.increment('notification.error', { type, reason: 'creation_failed' });
    throw error; // Re-throw for the controller/caller to handle
  }
}

/**
 * Process notification from message queue.
 * (Should likely live in a separate consumer/worker module)
 * NOTE: This function previously called deliverNotificationRealtime.
 *       Its purpose might need re-evaluation if the queue's only consumer was real-time delivery.
 */
export async function processQueuedNotification(message) {
  logger.debug('Processing queued notification', { eventType: message.type, correlationId: message.correlationId });
  try {
    if (message.type === 'NOTIFICATION_CREATED') {
      const { notificationId, userId, type, content } = message.payload;
      // WebSocket functionality removed - no action needed here anymore for real-time delivery.
      // Consider if other actions should happen based on this queued event.
      logger.info('Processing NOTIFICATION_CREATED event from queue (real-time delivery removed)', {
          notificationId, userId, type, correlationId: message.correlationId
      });
    }
    return true;
  } catch (error) {
    logger.error('Error processing queued notification', { error: error.message, correlationId: message.correlationId, messageType: message.type });
    metrics.increment('notification.queue_processing_error', { type: message.type });
    return false;
  }
}

/**
 * Get user's notifications using the repository and normalize results.
 */
export async function getUserNotifications(userId, options = {}) {
    const { limit = 20, offset = 0, includeRead = false, subscriptionId = null } = options;
    logger.debug('Getting user notifications (service layer)', { userId, options });
    try {
        // Fetch raw data from repository
        const rawNotifications = await findUserNotifications(userId, { limit, offset, includeRead, subscriptionId });

        // Normalize each notification
        return rawNotifications.map(notification => {
            try {
                // Pass raw DB record to normalizer
                return normalizeNotification(notification);
            } catch (error) {
                logger.error('Error normalizing notification', { error: error.message, notificationId: notification.id, userId });
                // Return a consistent error structure if normalization fails
                return {
                    id: notification.id || `error-${Date.now()}`,
                    userId: userId,
                    type: 'ERROR',
                    title: 'Error Processing Notification',
                    content: `Failed to process notification content: ${error.message}`,
                    read: notification.read !== undefined ? notification.read : false,
                    createdAt: notification.created_at || new Date().toISOString(),
                    metadata: { error: true, originalError: error.message }
                };
            }
        });
    } catch (error) {
        logger.error('Error fetching user notifications (service layer)', { error: error.message, stack: error.stack, userId, options });
        // Return empty array on failure to avoid breaking UI
        return [];
    }
}

/**
 * Mark notification as read using the repository.
 */
export async function markNotificationAsRead(notificationId, userId) {
  logger.debug('Marking notification as read (service layer)', { notificationId, userId });
  try {
    const success = await markNotificationRead(notificationId, userId);
    logger.debug('Mark notification read result', { notificationId, userId, success });
    return success;
  } catch (error) {
    logger.error('Error marking notification as read (service layer)', { error: error.message, notificationId, userId });
    throw error; // Re-throw for controller
  }
}

/**
 * Delete a notification using the repository.
 */
export async function deleteNotification(notificationId, userId) {
  logger.debug('Deleting notification (service layer)', { notificationId, userId });
  try {
    const success = await deleteNotificationById(notificationId, userId);
    logger.debug('Delete notification result', { notificationId, userId, success });
    if (success) {
        metrics.increment('notification.deleted', { reason: 'explicit_request', userId });
    } else {
        metrics.increment('notification.delete_failed', { reason: 'ownership_mismatch_or_not_found', userId });
    }
    return success;
  } catch (error) {
    logger.error('Error deleting notification (service layer)', { error: error.message, stack: error.stack, notificationId, userId });
    metrics.increment('notification.delete_error', { reason: 'db_error', userId });
    throw error; // Re-throw for controller
  }
}

/**
 * Delete all notifications for a user using the repository.
 */
export async function deleteAllNotifications(userId, { subscriptionId } = {}) {
  logger.debug('Deleting all notifications (service layer)', { userId, subscriptionId });
  try {
    const deletedCount = await deleteAllUserNotifications(userId, { subscriptionId });
    logger.debug('Delete all notifications result', { userId, subscriptionId, deletedCount });
    metrics.increment('notification.bulk_deleted', { count: deletedCount, userId });
    return deletedCount;
  } catch (error) {
    logger.error('Error deleting all notifications (service layer)', { error: error.message, stack: error.stack, userId, subscriptionId });
    metrics.increment('notification.bulk_delete_error', { reason: 'db_error', userId });
    throw error; // Re-throw for controller
  }
}

/**
 * Publish to email notification topic.
 * (Consider extracting to a separate email/queueing service)
 */
export async function publishToEmailNotificationTopic({ notificationId, userId, email, notification, transactionId }) {
  logger.debug('Publishing to email topic', { notificationId, userId, email, correlationId: transactionId });
  try {
    // Logic to determine topic (e.g., based on user prefs or immediacy)
    // Keep the test user check for now, but ideally configure this
    const isTestUser = email === process.env.TEST_EMAIL || email === 'nifyacorp@gmail.com';
    const topicName = isTestUser ? 'email-notifications-immediate' : 'email-notifications-daily';

    await pubsubClient.publishMessage(topicName, {
      userId,
      email,
      notification, // Pass the already constructed notification payload
      timestamp: new Date().toISOString(),
      correlationId: transactionId
    });

    logger.debug(`Published notification to Pub/Sub topic: ${topicName}`, { notificationId, userId, email, correlationId: transactionId });
    metrics.increment('notification.email_queued', { type: notification.type, userId, immediate: isTestUser });
    return true;
  } catch (error) {
    logger.error('Failed to publish email notification to Pub/Sub', { error: error.message, stack: error.stack, notificationId, userId, correlationId: transactionId });
    metrics.increment('notification.email_publish_error', { type: notification.type, userId, error: error.code || 'unknown' });
    return false; // Do not fail the primary operation
  }
}

/**
 * Count unread notifications using the repository.
 */
export async function countUnreadNotifications(userId) {
  logger.debug('Counting unread notifications (service layer)', { userId });
  try {
    const count = await countUnreadUserNotifications(userId);
    logger.debug('Unread notification count result', { userId, count });
    return count;
  } catch (error) {
    logger.error('Error counting unread notifications (service layer)', { error: error.message, stack: error.stack, userId });
    // Return 0 on error to prevent breaking UI, but log the error
    return 0;
  }
}

// Note: Removed module.exports, using ES export syntax instead. 